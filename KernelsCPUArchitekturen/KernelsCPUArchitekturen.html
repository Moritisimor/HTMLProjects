<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="Icon" type="image/png" href="/KernelSeite/KernelSeiteIcon.png">
    <link rel="stylesheet" href="KernelsCPUArchitekturen.css">
    <title>Prozessorarchitekturen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
</head>
<body>
    <div class="SiteContent">
        <h1>Hier wird sich mit CPU-Architekturen beschäftigt!</h1>

        <div class="RISCVSCISC">
            <h2>RISC VS CISC</h2>
            <h3><img src="RISC.png" width="50px" height="50px" alt="Selbstgemachtes RISC Logo">RISC</h3>
            <p>Dies steht für Reduced Instruction Set Computing und beschreibt einen Befehlssatz, der weniger umfangreich, aber effizienter ist.</p>
            <p>Kurzgesagt: Weniger Leistung, dafür effizienter.</p>
            <h3><img src="CISC.png" width="50px" height="50px" alt="Selbstgemachtes CISC Logo">CISC</h3>
            <p>Dies steht für Complex Instruction Set Computing und beschreibt einen Befehlssatz, der umfangreicher, aber weniger effizient ist.</p>
            <p>Kurzgesagt: Mehr Leistung, dafür weniger Effizienz.</p>
        </div>

        <h2>Welche Architekturen gibt es?</h2>

        <div class="x86_64imDetail">
            <h3><img src="x86.png" width="50px" height="50px" alt="Selbstgemachtes x86 Logo">x86_64</h3>
            <p>Eine sehr bekannte Prozessorarchitektur für Desktops und Laptops. x86_64 zeichnet sich durch das Complex Instruction Set Computing (CISC) aus. 
            Das bedeutet dass x86_64 Befehlssätze umfangreicher, aber nicht so energieeffizient wie Architekturen mit einem Reduced Instruction Set (RISC) sind.</p>
        </div>

        <div class="ARM64imDetail">
            <h3><img src="ARM.png" width="50px" height="50px" alt="Selbstgemachtes ARM-imitierendes Logo">ARM64</h3>
            <p>Eine weitere sehr bekannte Prozessorarchitektur für Handys, Tablets und manche Laptops. 
            ARM64 hebt sich durch RISC hervor, was die Befehlssätze einfacher, und die Architektur energieeffizienter macht.</p>
        </div>

        <div class="RISC-VimDetail">
            <h3><img src="R-V.png" width="50px" height="50px" alt="Selbstgemachtes RISC-V Logo">RISC-V</h3>
            <p>RISC-V ist im Vergleich zu den anderen Architekturen eher unbekannt, aber nicht zu unterschätzen! 
            Anders als die anderen Architekturen ist hier alles quelloffen und jeder kann theoretisch selbst RISC-V CPUs entwerfen, herstellen und verwenden.</p>
        </div>

        <div class="ArchitekturenImKernelKontext">
            <h2>Wie unterscheiden sich diese Architekturen im Bezug auf Kernels?</h2>
                <h3><img src="sys.png" width="30px" height="30px" alt="Selbstgemachtes Sys-Symbol">Syscalls</h3>
                <p>System Calls werden anders umgesetzt! Syscalls sind dafür da, um dem Kernelspace aus dem Userspace etwas mitzuteilen.
                Das betrifft z. B. das Starten eines Programmes oder auch das Schließen. Die Syscalls werden, je nach Architektur des Prozessors,
                anders gehandhabt und anders in Maschinencode übersetzt, aber der Output bleibt der gleiche, sofern alles glatt lief bei der Übersetzung.</p>

                <h3><img src="BIOS.png" width="30px" height="30px" alt="Selbstgemachtes BIOS-Symbol">Bootprozesse</h3>
                <h4><img src="UEFI.png" width="30px" height="30px" alt="Selbstgemachtes UEFI-Symbol">UEFI</h4>
                <p>Beim Starten eines x86_64 basiertem System gibt es viel Standardisierung mit UEFI und BIOS. Ein UEFI-basiertes System
                beginnt mit Platform Initializing, dort wird der Rechner in einen Status versetzt, in dem er zumindest in der Lage ist, UEFI
                Prozesse auszuführen, wie etwa das Treiberinitialisieren und das Identifizieren von Bootgeräten. Dies bleibt auch zur Laufzeit des
                Betriebssystems aktiv, um z. B. die Systemzeit abzufragen oder um Power States zu verwalten.</p>

                <h4><img src="ARM.png" width="30px" height="30px" alt="Selbstgemachtes ARM imitierendes Symbol">ARM64 Bootprozess</h4>
                <p>Hier ist es ähnlich wie mit UEFI, allerdings ist hier alles sehr herstellerspezifisch und oftmals proprietär. 
                    <h5>Nach dem Systemstart</h5>
                        <p>Nach dem erfolgreichen Starten des PCs  wird vom Bootloader wird erwartet, jeglichen Arbeitsspeicher zu finden und zu initialisieren. 
                        Hier gibt es allerdings keine einheitliche Methode. Manche Bootloader haben interne Algorithmen um RAM zu finden und dessen Größe zu 
                        bestimmen, andere proprietäre Bootloader sind auf ihr jeweiliges Gerät maßgeschneidert.</p>
                    <h5>Nach der Raminitialiserung</h5>
                        <p>Dann muss der Device Tree gestartet werden, eine Datenstruktur, die die Hardware des Systems beschreibt. Dieser Prozess ist nützlich 
                        um nicht Daten für jedes einzelne mögliche Gerät enthalten zu müssen, was Speicherplatz spart.
                    <h5>Nach der DTB-Initialiserung</h5>
                        <p>falls das Kernel Image komprimiert ist, wird dieses dekomprimiert. Falls nicht ist ein nicht komprimiertes Kernel Image enthalten, 
                        also gibt es nichts zu dekomprimieren. Nun kommt der letzte Schritt: Das Kernel Image wird gerufen und die Kontrolle wird an den Kernel übergeben.</p>
        </div>

        <h6>Kurzer Hinweis:</h6>
        <p>Alle hier genannten Architekturen und Technologien sind geistiges Eigentum ihres jeweiligen
        Eigentümers und ich beanspruche keinerlei Rechte an den hier genannten Architekturen oder Technologien.
        Diese Seite ist alleine dafür da, um zu informieren.</p>
    </div>
</body>
</html>
